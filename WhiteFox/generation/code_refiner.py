"""
Code refining utilities.

Handles parsing generated code from LLM outputs and ensuring required imports.
"""

import re
from generation.code_processor import process_code


def parse_generated_code(generated_text: str) -> str:
    """
    Parse generated code from LLM output.
    Extracts Python code from markdown code blocks or returns cleaned text.
    
    Args:
        generated_text: Raw text generated by the LLM
        
    Returns:
        Cleaned Python code string
    """
    # Try to extract code from markdown code blocks
    # Look for ```python or ``` code blocks
    code_block_pattern = r'```(?:python)?\s*\n(.*?)\n```'
    matches = re.findall(code_block_pattern, generated_text, re.DOTALL)
    
    if matches:
        # If we found code blocks, use the last one (most likely to be complete)
        return matches[-1].strip()
    
    # If no code blocks found, return the text as-is but strip common prefixes/suffixes
    text = generated_text.strip()
    
    # Remove common instruction prefixes that LLMs might add
    prefixes_to_remove = [
        "Here is the code:",
        "Here's the code:",
        "Here is a TensorFlow model:",
        "Here's a TensorFlow model:",
    ]
    
    for prefix in prefixes_to_remove:
        if text.lower().startswith(prefix.lower()):
            text = text[len(prefix):].strip()
            break
    
    return text


def ensure_imports(code: str) -> str:
    """
    Ensure required imports are present in the code.
    
    Adds:
    - import tensorflow as tf (if tf is used but not imported)
    - import numpy as np (if np is used but not imported)
    """
    lines = code.split('\n')
    
    uses_tf = re.search(r'\btf\.', code) or 'tf.' in code or 'tf ' in code
    uses_np = re.search(r'\bnp\.', code) or 'np.' in code or 'np ' in code
    
    has_tf_import = re.search(r'import\s+tensorflow\s+as\s+tf', code, re.IGNORECASE)
    has_np_import = re.search(r'import\s+numpy\s+as\s+np', code, re.IGNORECASE)
    
    imports_to_add = []
    if uses_tf and not has_tf_import:
        imports_to_add.append('import tensorflow as tf')
    if uses_np and not has_np_import:
        imports_to_add.append('import numpy as np')
    
    if imports_to_add:
        insert_idx = 0
        for i, line in enumerate(lines):
            stripped = line.strip()
            if stripped and not stripped.startswith('#'):
                insert_idx = i
                break
        
        for imp in reversed(imports_to_add):
            lines.insert(insert_idx, imp)
        
        code = '\n'.join(lines)
    
    return code


def refine_generated_code(generated_text: str) -> str:
    """
    Complete pipeline for refining generated code.
    
    This combines all refinement steps:
    1. Parse code from LLM output (extract from markdown, etc.)
    2. Ensure required imports are present
    3. Apply WhiteFox code processing (AST transformation)
    
    Args:
        generated_text: Raw text generated by the LLM
        
    Returns:
        Fully processed executable code with input_data variable
    """
    # 1. Parse code from LLM output
    parsed_code = parse_generated_code(generated_text)
    
    # 2. Ensure imports are present
    code_with_imports = ensure_imports(parsed_code)
    
    # 3. Apply WhiteFox code processing (AST transformation)
    processed_code = process_code(code_with_imports)
    
    return processed_code

