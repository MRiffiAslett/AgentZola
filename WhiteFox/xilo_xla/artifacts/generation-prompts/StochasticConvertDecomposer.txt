### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `ReshapeReshapeForwarding` in TensorFlow XLA.

# Description
The model should contain the following pattern:
```
t1 = tf.reshape(input_tensor, ...)
t2 = tf.reshape(t1, input_tensor.shape)
```
The pattern describes that there are two reshape operators in the model. The first `reshape` operator transforms a tensor input `input_tensor` from `input_tensor.shape` to any new shape, and the second `reshape` operator transforms the output of first `reshape` back to `input_tensor.shape`.


# Model
class Model(tf.keras.Model):

  def __init__(self):
    super(Model, self).__init__()

  def call(self, x1):
    x2 = tf.reshape(x1, [2,2])
    return tf.reshape(x2, [4])

# Initializing the model
m = Model()

# Inputs to the model
input_shape = [4]
x1 = tf.constant([4.,5.,6.,7.], shape=input_shape)

# Call model
y = m(x1)




### Characteristics of the TensorFlow model that trigger the optimization pass `StochasticConvertDecomposer` in TensorFlow XLA

In TensorFlow XLA, the `StochasticConvertDecomposer` optimization pass is triggered when a specific pattern involving a `StochasticConvert` operation is found in the computational graph. The characteristics of a TensorFlow model that lead to this optimization are as follows:

1. The model must contain a `StochasticConvert` operation.
2. The `StochasticConvert` operation must have exactly two operands.
3. The operation is intended to convert from one data type to another, where the target type is a signed integral type.
4. The second operand of the `StochasticConvert` operation is utilized as a random value, which influences the stochastic nature of the conversion.

The typical use case for this operation and its corresponding optimization involves converting a floating-point number to an integer while considering stochastic aspects such as rounding behaviors influenced by a random number. The optimization pass decomposes the `StochasticConvert` into several finer operations that handle the conversion deterministically based on the random input, managing edge cases such as minimum and maximum values specifically for signed integer types.

Here is an example scenario in TensorFlow (pseudo-code for illustrating the pattern, actual TensorFlow APIs might not directly expose `StochasticConvert`):

```python
# Assuming 'input_tensor' is a floating-point Tensor and 'random_tensor' is a Tensor of random values
# 'stochastic_convert' is a hypothetical function representing the StochasticConvert operation
output_tensor = stochastic_convert(input_tensor, random_tensor, target_dtype=tf.int32)
```

In this example, `input_tensor` is converted to a 32-bit integer with the conversion process influenced by `random_tensor`. The XLA optimization would decompose this operation into several steps ensuring correct handling of rounding and edge cases, thus potentially improving execution efficiency.