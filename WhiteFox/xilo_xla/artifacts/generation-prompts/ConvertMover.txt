### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `ReshapeReshapeForwarding` in TensorFlow XLA.

# Description
The model should contain the following pattern:
```
t1 = tf.reshape(input_tensor, ...)
t2 = tf.reshape(t1, input_tensor.shape)
```
The pattern describes that there are two reshape operators in the model. The first `reshape` operator transforms a tensor input `input_tensor` from `input_tensor.shape` to any new shape, and the second `reshape` operator transforms the output of first `reshape` back to `input_tensor.shape`.


# Model
class Model(tf.keras.Model):

  def __init__(self):
    super(Model, self).__init__()

  def call(self, x1):
    x2 = tf.reshape(x1, [2,2])
    return tf.reshape(x2, [4])

# Initializing the model
m = Model()

# Inputs to the model
input_shape = [4]
x1 = tf.constant([4.,5.,6.,7.], shape=input_shape)

# Call model
y = m(x1)


### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `AllReduceCombiner` in TensorFlow XLA.

### Characteristics of TensorFlow Model for `ReshapeReshapeForwarding` Optimization

For the `ReshapeReshapeForwarding` optimization in TensorFlow XLA to be triggered, the TensorFlow model must contain a sequence of two `reshape` operations, where the second reshape operation reverses the shape transformation made by the first. Specifically:

- The first `reshape` operation changes the shape of an input tensor `input_tensor` to any arbitrary new shape.
- The second `reshape` operation changes the shape of the tensor resulting from the first reshape back to the original shape of `input_tensor`.

This pattern can be illustrated with the following TensorFlow code:

```python
import tensorflow as tf

input_tensor = tf.random.uniform([10, 20])  # Original shape (10, 20)
t1 = tf.reshape(input_tensor, [200])        # Reshape to new shape (200,)
t2 = tf.reshape(t1, [10, 20])               # Reshape back to original shape (10, 20)
```

Here, `t1` is the tensor obtained from the first reshape operation, and `t2` is the result of the second reshape operation that restores the tensor to its original shape. This pattern is eligible for the `ReshapeReshapeForwarding` optimization, leading to the potential elimination of unnecessary reshape operations.

### Characteristics of TensorFlow Model for `ConvertMover` Optimization

The `ConvertMover` optimization pass in TensorFlow XLA is triggered when there is an opportunity to move precision conversion (`kConvert` operations) closer to the inputs or outputs of an operation to potentially simplify the computation or enable further optimizations. The model characteristics that trigger this optimization include:

- The presence of operations where the operands are either constants or results of a `kConvert` operation. These operations must be of types that commute with precision conversion (`kConvert`). Commutable operations include `kConcatenate`, `kPad`, `kReshape`, `kSlice`, and `kTranspose`.
- For moving the increase precision conversion down the graph (`instr(increase_precision(x)) -> increase_precision(instr(x))`), all operands involved in the `instr` must be either constants or have a single `kConvert` as a user, and all `kConvert` operations should convert from the same source data type.
- For moving the decrease precision conversion up the graph (`decrease_precision(instr(x)) -> instr(decrease_precision(x))`), the instruction consuming the `kConvert` result should be an operation that commutes with `kConvert`, and the precision conversion should be from a higher bit-width to a lower bit-width, not involving sub-byte non-predicate types.

Here is an illustrative TensorFlow code snippet for moving increase precision conversion:

```python
import tensorflow as tf

x = tf.constant([1.0, 2.0], dtype=tf.float16)
y = tf.convert_to_tensor(x, dtype=tf.float32)
z = tf.reshape(y, [2, 1])  # Reshape commutes with convert
```

In the above example, the model can potentially benefit from the `ConvertMover` optimization by moving the conversion from `float16` to `float32` closer to the constant tensor `x`, thereby simplifying the graph.