### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `ReshapeReshapeForwarding` in TensorFlow XLA.

# Description
The model should contain the following pattern:
```
t1 = tf.reshape(input_tensor, ...)
t2 = tf.reshape(t1, input_tensor.shape)
```
The pattern describes that there are two reshape operators in the model. The first `reshape` operator transforms a tensor input `input_tensor` from `input_tensor.shape` to any new shape, and the second `reshape` operator transforms the output of first `reshape` back to `input_tensor.shape`.


# Model
class Model(tf.keras.Model):

  def __init__(self):
    super(Model, self).__init__()

  def call(self, x1):
    x2 = tf.reshape(x1, [2,2])
    return tf.reshape(x2, [4])

# Initializing the model
m = Model()

# Inputs to the model
input_shape = [4]
x1 = tf.constant([4.,5.,6.,7.], shape=input_shape)

# Call model
y = m(x1)


### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `AllReduceCombiner` in TensorFlow XLA.

### Characteristics of TensorFlow model for `ReshapeReshapeForwarding` optimization in TensorFlow XLA:

The TensorFlow model must have at least two consecutive `tf.reshape` operations where:
1. The first `reshape` operation changes the shape of an input tensor `input_tensor` to any new shape.
2. The second `reshape` operation transforms the tensor back to the original shape of `input_tensor`.

This pattern indicates a redundancy in operations as the final shape after the second reshape is the same as the initial shape of the input tensor, making the sequence of reshapes effectively a no-op with respect to the tensor shape.

**Example Model:**
```python
import tensorflow as tf

# Assume input_tensor is some predefined tensor
input_tensor = tf.random.normal([10, 10])

# First reshape operation (any arbitrary new shape)
t1 = tf.reshape(input_tensor, [100])

# Second reshape operation that reverts to the original shape of input_tensor
t2 = tf.reshape(t1, [10, 10])
```

### Characteristics of TensorFlow model for `ConditionalCanonicalizer` optimization in TensorFlow XLA:

The TensorFlow model must include a `tf.cond` or similar conditional operation that meets the following criteria:
1. The conditional operation (`tf.cond`) involves branches where either the inputs to the branches, the outputs from the branches, or the result of the whole conditional operation itself are not already in tuple form.
2. The model will trigger optimizations that convert these non-tuple inputs, outputs, or results into tuples if they are not already so. This includes:
   - Ensuring all branch inputs are tuples.
   - Ensuring all branch outputs are tuples.
   - Ensuring the final output of the conditional operation is a tuple.

This transformation standardizes the structure of data across different branches and the main computation, facilitating potential further optimizations and simplifications.

**Example Model:**
```python
import tensorflow as tf

# Define a simple conditional operation
x = tf.constant(5)
y = tf.constant(3)
def f1(): return tf.multiply(x, 17)
def f2(): return tf.add(y, 23)

# Conditional operation where neither branches nor outputs are initially tuples
result = tf.cond(tf.less(x, y), f1, f2)
```

In the above model, neither `f1` nor `f2` returns a tuple, and neither are the inputs to these functions tuples. The `ConditionalCanonicalizer` would work to encapsulate the inputs and outputs in tuples, normalizing the structure of the computation.