### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `ReshapeReshapeForwarding` in TensorFlow XLA.

# Description
The model should contain the following pattern:
```
t1 = tf.reshape(input_tensor, ...)
t2 = tf.reshape(t1, input_tensor.shape)
```
The pattern describes that there are two reshape operators in the model. The first `reshape` operator transforms a tensor input `input_tensor` from `input_tensor.shape` to any new shape, and the second `reshape` operator transforms the output of first `reshape` back to `input_tensor.shape`.


# Model
class Model(tf.keras.Model):

  def __init__(self):
    super(Model, self).__init__()

  def call(self, x1):
    x2 = tf.reshape(x1, [2,2])
    return tf.reshape(x2, [4])

# Initializing the model
m = Model()

# Inputs to the model
input_shape = [4]
x1 = tf.constant([4.,5.,6.,7.], shape=input_shape)

# Call model
y = m(x1)




### Characteristics of TensorFlow Model for `ReshapeReshapeForwarding` Optimization:

The TensorFlow model needs to follow a specific pattern to trigger the `ReshapeReshapeForwarding` optimization in XLA. This pattern includes two consecutive `reshape` operations where:

1. The first `reshape` operation changes the shape of an input tensor `input_tensor` to any arbitrary shape.
2. The second `reshape` operation changes the shape of the tensor resulting from the first reshape back to the original shape of `input_tensor`.

Here's an illustrative TensorFlow code snippet:

```python
import tensorflow as tf

# Original input tensor
input_tensor = tf.random.uniform(shape=[10, 20])

# First reshape operation
reshaped_tensor = tf.reshape(input_tensor, [200])

# Second reshape operation that restores the original shape
restored_tensor = tf.reshape(reshaped_tensor, [10, 20])
```

In this example, `input_tensor` is first reshaped to `[200]`, and then it is reshaped back to its original shape `[10, 20]`. This sequence will activate the `ReshapeReshapeForwarding` optimization if the model is compiled with TensorFlow XLA.

### Characteristics of TensorFlow Model for `DynamicIndexSplitter` Optimization:

The `DynamicIndexSplitter` optimization is triggered in TensorFlow XLA for models containing `DynamicSlice` or `DynamicUpdateSlice` operations under specific conditions:

1. The operation involves a tensor (`dynamic_op`) with any number of dimensions.
2. The indices used for slicing or updating are not scalars but vectors, which means the index tensor has more than one element.

A typical scenario where this optimization would be triggered is when a model employs dynamic slicing or updating operations with non-scalar indices. Here's an example:

```python
import tensorflow as tf

# Tensor to be dynamically sliced
input_tensor = tf.random.uniform(shape=[10, 20, 30])

# Non-scalar index tensor
index_tensor = tf.constant([1, 2])

# Dynamic slice operation
sliced_tensor = tf.slice(input_tensor, index_tensor, [5, 5, 5])

# Dynamic update slice operation
update_value = tf.zeros(shape=[5, 5, 5])
updated_tensor = tf.tensor_scatter_nd_update(input_tensor, [index_tensor], update_value)
```

In this example, `index_tensor` is a vector, used for dynamically slicing and updating `input_tensor`. The `DynamicIndexSplitter` optimization would potentially be triggered to handle these operations more efficiently by converting the index vector into scalar indices.

These configurations in TensorFlow models would lead the corresponding XLA optimization passes to be activated during compilation, improving execution performance by simplifying operations or enhancing data handling.