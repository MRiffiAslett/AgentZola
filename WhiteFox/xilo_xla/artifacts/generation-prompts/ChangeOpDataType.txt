### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `ReshapeReshapeForwarding` in TensorFlow XLA.

# Description
The model should contain the following pattern:
```
t1 = tf.reshape(input_tensor, ...)
t2 = tf.reshape(t1, input_tensor.shape)
```
The pattern describes that there are two reshape operators in the model. The first `reshape` operator transforms a tensor input `input_tensor` from `input_tensor.shape` to any new shape, and the second `reshape` operator transforms the output of first `reshape` back to `input_tensor.shape`.


# Model
class Model(tf.keras.Model):

  def __init__(self):
    super(Model, self).__init__()

  def call(self, x1):
    x2 = tf.reshape(x1, [2,2])
    return tf.reshape(x2, [4])

# Initializing the model
m = Model()

# Inputs to the model
input_shape = [4]
x1 = tf.constant([4.,5.,6.,7.], shape=input_shape)

# Call model
y = m(x1)


### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `AllReduceCombiner` in TensorFlow XLA.

### Characteristics of the TensorFlow model that trigger the `ChangeOpDataType` optimization pass in TensorFlow XLA

The `ChangeOpDataType` optimization pass in TensorFlow XLA is designed to change the data type of operations under certain conditions. The optimization will trigger if the following characteristics are met within the TensorFlow model:

1. **Uniform Operand Data Types:**
   The model contains operations whose operands all have the same data type. This uniformity is necessary because the pass checks for a common data type among all operands of an operation.

2. **Valid Operation for Data Type Change:**
   The operation must meet specific criteria determined by an operation matcher (`op_matcher_`). This typically includes operations that are computationally significant or that benefit from operating in a different precision (like matrix multiplications or convolutions).

3. **Array Data Type:**
   The operation must produce an array as its output. This excludes operations that do not produce tensors or those that produce non-array types.

4. **Exclusion of Parameter Operations:**
   The operations cannot be parameter operations, as these are typically inputs to the computation and are not altered in terms of data type within the optimization scope.

5. **Mapped Conversion Types:**
   The existing data type of the operation's operands must be mapped to a new data type according to a predefined map (`to_type_map_`). If no mapping exists for the operand's data type, the optimization does not trigger.

6. **Exclusion of Specific Configurations:**
   In environments configured to use OneDNN, certain operations are excluded from this optimization based on additional checks (like whether they are suitable for OneDNN optimizations).

Here is a TensorFlow model example that could potentially trigger this optimization:

```python
import tensorflow as tf

# Example TensorFlow model
input_tensor = tf.constant([[1.0, 2.0], [3.0, 4.0]], dtype=tf.float32)
layer = tf.keras.layers.Dense(units=2)

# Assuming the operation within Dense layer can be matched by op_matcher_ and has a suitable data type conversion in to_type_map_
output = layer(input_tensor)

# Convert the model to a TensorFlow graph
graph_func = tf.function(output)

# (Hypothetical) Compile with XLA which would invoke the ChangeOpDataType pass if conditions are met
compiled_func = graph_func.experimental_compile()
```

In this example, if the `Dense` layer operation (likely a matrix multiplication) is matched by `op_matcher_` and if `tf.float32` is in the `to_type_map_` with a desirable conversion type, the `ChangeOpDataType` optimization could be triggered. This would involve changing the data type of the operationâ€™s computation, potentially improving performance or reducing resource usage.