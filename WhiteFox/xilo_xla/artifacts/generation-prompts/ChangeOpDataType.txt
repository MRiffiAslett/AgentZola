### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `ReshapeReshapeForwarding` in TensorFlow XLA.

# Description
The model should contain the following pattern:
```
t1 = tf.reshape(input_tensor, ...)
t2 = tf.reshape(t1, input_tensor.shape)
```
The pattern describes that there are two reshape operators in the model. The first `reshape` operator transforms a tensor input `input_tensor` from `input_tensor.shape` to any new shape, and the second `reshape` operator transforms the output of first `reshape` back to `input_tensor.shape`.


# Model
class Model(tf.keras.Model):

  def __init__(self):
    super(Model, self).__init__()

  def call(self, x1):
    x2 = tf.reshape(x1, [2,2])
    return tf.reshape(x2, [4])

# Initializing the model
m = Model()

# Inputs to the model
input_shape = [4]
x1 = tf.constant([4.,5.,6.,7.], shape=input_shape)

# Call model
y = m(x1)




### Characteristics of TensorFlow models triggering the `ChangeOpDataType` optimization in TensorFlow XLA

#### Description:
The `ChangeOpDataType` optimization is triggered in TensorFlow models where a specific computation or operation involves operands with uniform data types that can be converted to a different, target data type as specified by a mapping (`to_type_map_`). This optimization process modifies the operation to perform computations in the new data type and then converts the result back to the original data type.

#### Characteristics:
1. **Uniform Operand Data Types**: All operands of an operation must have the same data type. This uniformity is checked across all operands of an instruction.

2. **Operation Matches Specific Criteria**: The operation must match certain criteria defined by `op_matcher_`. This could involve specific types of operations or computations.

3. **Exclusion of Certain Operations**: The operation should not be a parameter operation (`HloOpcode::kParameter`), ensuring it's an computational instruction rather than a function parameter.

4. **Applicable Data Type Mapping**: There exists a predefined mapping (`to_type_map_`) that allows conversion from the current data type of the operands (uniform type) to a new target data type.

5. **Array-Type Shape**: The shape of the operationâ€™s output must be an array. This ensures the operation produces a tensor output.

6. **Non-Fusion Computations**: The operation must occur in non-fusion computations, meaning it is not part of a combined set of operations optimized together as a single unit.

#### Example Code Pattern:
```python
import tensorflow as tf

# Assuming a specific mapping is defined in XLA for conversion, e.g., from float32 to float16
x = tf.constant([[1.0, 2.0], [3.0, 4.0]], dtype=tf.float32)
y = tf.constant([[5.0, 6.0], [7.0, 8.0]], dtype=tf.float32)

# An operation where all operands are float32 and can be converted to float16
z = tf.add(x, y)  # Simplistic example where add could be targeted by 'op_matcher_'

# This model would trigger the optimization if 'add' is matched and float32 to float16 conversion is specified
```

In this example, if the addition operation (`tf.add`) is matched by `op_matcher_` and there exists a map entry converting `float32` to `float16`, then the optimization would replace this operation with one computed in `float16` and then convert the result back to `float32`. This can be particularly beneficial for enhancing performance and reducing memory usage in models heavily utilizing specific data type operations.