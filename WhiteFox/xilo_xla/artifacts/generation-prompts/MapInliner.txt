### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `MapInliner` in TensorFlow XLA.

# Description
The `MapInliner` optimization pass in TensorFlow XLA is designed to inline `Map` operations under specific circumstances to simplify the computation graph and potentially improve performance. A TensorFlow model will trigger this optimization when it contains `Map` operations satisfying the following characteristics:

1. **Single Operation Sub-Computation**: The function applied by the `Map` operation (referred to as `to_apply` in the XLA code) must consist of exactly one operation, which is the root operation of the sub-computation.

2. **Root Operation Requirements**:
   - **Operands Are Parameters**: All operands of the root operation must be parameters of its sub-computation. This ensures that the operation directly manipulates the inputs provided by the `Map` operation without additional computation or dependencies.
   - **Not a Fusion Operation**: The root operation must not be a fusion operation, as these are not supported for cloning in this optimization pass.

Hereâ€™s an example TensorFlow model snippet that would likely trigger this optimization:

```python
import tensorflow as tf

# Define a simple element-wise addition using `tf.map_fn`
elems = tf.constant([1, 2, 3, 4, 5])
increment = lambda x: x + 1
incremented_elems = tf.map_fn(increment, elems)

# Convert to a TensorFlow graph to be optimized by XLA
graph = tf.function(incremented_elems)
```

In this example, the `tf.map_fn` applies a simple increment operation (`x + 1`) to each element. This operation is a good candidate for the `MapInliner` optimization because:

- The lambda function is a single-operation sub-computation.
- The operation (`x + 1`) directly uses the input `x` (a parameter) without additional computation.

When processed by XLA with optimization enabled, the `MapInliner` is likely to inline the map operation, replacing it with equivalent operations that directly compute the result in the main computation graph, thus potentially avoiding the overhead of the map setup and teardown.
