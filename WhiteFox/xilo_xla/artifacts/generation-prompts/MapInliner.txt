### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `ReshapeReshapeForwarding` in TensorFlow XLA.

# Description
The model should contain the following pattern:
```
t1 = tf.reshape(input_tensor, ...)
t2 = tf.reshape(t1, input_tensor.shape)
```
The pattern describes that there are two reshape operators in the model. The first `reshape` operator transforms a tensor input `input_tensor` from `input_tensor.shape` to any new shape, and the second `reshape` operator transforms the output of first `reshape` back to `input_tensor.shape`.


# Model
class Model(tf.keras.Model):

  def __init__(self):
    super(Model, self).__init__()

  def call(self, x1):
    x2 = tf.reshape(x1, [2,2])
    return tf.reshape(x2, [4])

# Initializing the model
m = Model()

# Inputs to the model
input_shape = [4]
x1 = tf.constant([4.,5.,6.,7.], shape=input_shape)

# Call model
y = m(x1)




### Characteristics of TensorFlow Model Triggering `ReshapeReshapeForwarding` Optimization

For the `ReshapeReshapeForwarding` optimization pass in TensorFlow XLA to be triggered, the TensorFlow model must contain a sequence of two `tf.reshape` operations where:

1. The first `reshape` operation changes the shape of a tensor (`input_tensor`) to any arbitrary new shape.
2. The second `reshape` operation directly following the first, reverts the shape of the tensor back to the original shape of `input_tensor`.

This pattern effectively makes the sequence of reshape operations redundant, as the final tensor shape after both reshapes is the same as the initial shape.

#### Example:
```python
import tensorflow as tf

# Input tensor of shape (10, 10)
input_tensor = tf.random.normal([10, 10])

# First reshape operation changing the shape
t1 = tf.reshape(input_tensor, [100])

# Second reshape operation reverting the shape to original
t2 = tf.reshape(t1, [10, 10])
```
In this scenario, `t2` effectively has the same shape and content as `input_tensor`, triggering the `ReshapeReshapeForwarding` optimization to eliminate the redundant reshapes.

### Characteristics of TensorFlow Model Triggering `MapInliner` Optimization

For the `MapInliner` optimization pass in TensorFlow XLA to be triggered, the TensorFlow model must include a `tf.map_fn` operation where:

1. The function applied in `tf.map_fn` (letâ€™s call it `map_function`) consists of simple operations that only involve parameters (i.e., input arguments to the function) without any complex control flows or additional dependencies.
2. The `map_function` can be expressed as a direct operation on the input tensors, making the use of `map_fn` redundant.

This optimization pass is particularly triggered when the operations within the `map_function` are simple enough (like arithmetic operations directly on the parameters) that they can be directly applied outside of `map_fn`, thereby bypassing the overhead of the map operation.

#### Example:
```python
import tensorflow as tf

# Input tensor
input_tensor = tf.constant([[1, 2], [3, 4]])

# Simple operation function to be applied using map_fn
def simple_add(x):
    return x + 5

# Applying map_fn
result = tf.map_fn(simple_add, input_tensor)
```
In this example, the function `simple_add` directly operates on the input parameters with a simple addition. This scenario is ideal for the `MapInliner` optimization, which would replace the `map_fn` with a direct addition operation on `input_tensor`, thereby improving computational efficiency.