### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `ReshapeReshapeForwarding` in TensorFlow XLA.

# Description
The model should contain the following pattern:
```
t1 = tf.reshape(input_tensor, ...)
t2 = tf.reshape(t1, input_tensor.shape)
```
The pattern describes that there are two reshape operators in the model. The first `reshape` operator transforms a tensor input `input_tensor` from `input_tensor.shape` to any new shape, and the second `reshape` operator transforms the output of first `reshape` back to `input_tensor.shape`.


# Model
class Model(tf.keras.Model):

  def __init__(self):
    super(Model, self).__init__()

  def call(self, x1):
    x2 = tf.reshape(x1, [2,2])
    return tf.reshape(x2, [4])

# Initializing the model
m = Model()

# Inputs to the model
input_shape = [4]
x1 = tf.constant([4.,5.,6.,7.], shape=input_shape)

# Call model
y = m(x1)




### Characteristics of TensorFlow model triggering `ReshapeReshapeForwarding` optimization:

For the `ReshapeReshapeForwarding` optimization to be triggered in TensorFlow XLA, the following characteristics must be observed in the model:

1. **Sequential Reshape Operations:**
   - The model should contain two consecutive `tf.reshape` operations.
   - The first `reshape` operation changes the shape of an input tensor to any other shape.
   - The second `reshape` operation restores the tensor back to its original shape.

2. **Shape Matching:** 
   - The output shape of the second `reshape` must match the shape of the tensor before the first `reshape`.

**Example Code:**
```python
import tensorflow as tf

# Input tensor of shape (2, 3)
input_tensor = tf.constant([[1, 2, 3], [4, 5, 6]])

# First reshape operation (e.g., flattening the tensor)
reshaped_tensor = tf.reshape(input_tensor, [-1])

# Second reshape operation (restoring original shape)
output_tensor = tf.reshape(reshaped_tensor, tf.shape(input_tensor))

# output_tensor will have the same shape as input_tensor
```
In this example, `output_tensor` will have the same shape as `input_tensor`, and this pattern will trigger the `ReshapeReshapeForwarding` optimization if compiled with TensorFlow XLA.

### Characteristics of TensorFlow model triggering `HloConstantFolding` optimization:

For the `HloConstantFolding` optimization to be triggered, the model must exhibit the following characteristics:

1. **Constant Operands:**
   - At least one operand of an instruction must be a constant.

2. **Foldable Operations:**
   - The operation should not be inherently non-foldable, such as random number generation (`kRng`), asynchronous operations, or have side effects.

3. **Size Considerations:**
   - The total number of elements in the operands and the result should be below a threshold (e.g., 45 million elements), especially for default optimization levels to avoid excessive compilation times.

4. **Absence of Illegal Instructions:**
   - The operation must not include or be part of computations that include non-foldable instructions like `kAfterAll`.

5. **No Broadcast Expansion:**
   - Operations that dramatically increase the size of constants through broadcasts are not folded by default to avoid significant performance or memory overheads.

**Example Code:**
```python
import tensorflow as tf

# Constants
a = tf.constant([1, 2, 3])
b = tf.constant([4, 5, 6])

# Element-wise addition (foldable operation)
c = tf.add(a, b)

# The operation tf.add is foldable as both operands are constants,
# and it does not involve any side effects or illegal instructions.
```
In this example, the addition of two constant tensors can be folded at compile time, resulting in a constant tensor `c` with values `[5, 7, 9]`, thus triggering the `HloConstantFolding` optimization.