### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `ReshapeReshapeForwarding` in TensorFlow XLA.

# Description
The model should contain the following pattern:
```
t1 = tf.reshape(input_tensor, ...)
t2 = tf.reshape(t1, input_tensor.shape)
```
The pattern describes that there are two reshape operators in the model. The first `reshape` operator transforms a tensor input `input_tensor` from `input_tensor.shape` to any new shape, and the second `reshape` operator transforms the output of first `reshape` back to `input_tensor.shape`.


# Model
class Model(tf.keras.Model):

  def __init__(self):
    super(Model, self).__init__()

  def call(self, x1):
    x2 = tf.reshape(x1, [2,2])
    return tf.reshape(x2, [4])

# Initializing the model
m = Model()

# Inputs to the model
input_shape = [4]
x1 = tf.constant([4.,5.,6.,7.], shape=input_shape)

# Call model
y = m(x1)




### Characteristics of TensorFlow model for `ReshapeReshapeForwarding` Optimization

For the `ReshapeReshapeForwarding` optimization to be triggered, the TensorFlow model must exhibit a specific pattern in its operations:

1. **Sequential Reshape Operations**:
   - The model should contain a sequence of two consecutive `tf.reshape()` operations.
   - The first `reshape` operation changes the shape of a tensor (`input_tensor`) to any new shape.
   - The second `reshape` operation reverts the shape of the tensor back to the original shape of `input_tensor`.

2. **Shape Equality**:
   - The output shape of the second `reshape` must match the original shape of the tensor before the first `reshape`.

#### Example:
```python
import tensorflow as tf

# Assume input_tensor is a TensorFlow tensor with a known shape
input_tensor = tf.random.normal([8, 16])

# First reshape operation (changing shape)
t1 = tf.reshape(input_tensor, [2, 4, 16])

# Second reshape operation (restoring original shape)
t2 = tf.reshape(t1, tf.shape(input_tensor))

# t2 should now trigger the optimization, effectively becoming equivalent to input_tensor
```

### Characteristics of TensorFlow model for `BatchDotSimplification` Optimization

For the `BatchDotSimplification` optimization to be triggered, the TensorFlow model must meet several criteria related to its `tf.linalg.matmul` or batch dot operations:

1. **Equality of Batch Dimensions**:
   - The batch dimensions of the left-hand side (lhs) and right-hand side (rhs) tensors in the dot operation must be equal and strictly ascending.

2. **Contracting Dimensions**:
   - There must be exactly one contracting dimension specified in the dot operation.

3. **Presence of Degenerate Dimensions**:
   - At least one of the batch dimensions must be degenerate (i.e., dimension size is 1) in either the lhs or rhs tensor.

#### Example:
```python
import tensorflow as tf

# Assume lhs and rhs are tensors suitable for batch dot product
lhs = tf.random.normal([1, 5, 10])  # One degenerate batch dimension
rhs = tf.random.normal([1, 10, 3])  # Matching batch dimension

# Performing batch dot product
output = tf.linalg.matmul(lhs, rhs)

# This setup should trigger the optimization if the tensors meet all specific conditions
```

In both cases, the model structures need to precisely match these characteristics for the respective optimization passes to be triggered in TensorFlow XLA.