### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `ReshapeReshapeForwarding` in TensorFlow XLA.

# Description
The model should contain the following pattern:
```
t1 = tf.reshape(input_tensor, ...)
t2 = tf.reshape(t1, input_tensor.shape)
```
The pattern describes that there are two reshape operators in the model. The first `reshape` operator transforms a tensor input `input_tensor` from `input_tensor.shape` to any new shape, and the second `reshape` operator transforms the output of first `reshape` back to `input_tensor.shape`.


# Model
class Model(tf.keras.Model):

  def __init__(self):
    super(Model, self).__init__()

  def call(self, x1):
    x2 = tf.reshape(x1, [2,2])
    return tf.reshape(x2, [4])

# Initializing the model
m = Model()

# Inputs to the model
input_shape = [4]
x1 = tf.constant([4.,5.,6.,7.], shape=input_shape)

# Call model
y = m(x1)




### Characteristics of a TensorFlow Model that Trigger `ReshapeReshapeForwarding` Optimization

For a TensorFlow model to trigger the `ReshapeReshapeForwarding` optimization in TensorFlow XLA, the model must contain a sequence of two reshape operations where the output shape of the second reshape operation matches the shape of the tensor input to the first reshape operation. Specifically, the model should perform a reshape of a tensor to a new shape and then reshape it back to its original shape.

**Code Pattern Example:**
```python
import tensorflow as tf

# Assume input_tensor is defined and has a specific shape
input_tensor = tf.constant([[1, 2], [3, 4]])

# First reshape: changing the shape of input_tensor
t1 = tf.reshape(input_tensor, [4])

# Second reshape: reverting back to the original shape of input_tensor
t2 = tf.reshape(t1, input_tensor.shape)

# t2 will trigger the optimization if used in a graph executed by XLA
```

This pattern is common when intermediate reshape operations are used for layer operations or data manipulation but are later reversed, making the second reshape redundant.

### Characteristics of a TensorFlow Model that Trigger `SimplifyFpConversions` Optimization

The `SimplifyFpConversions` optimization is triggered in a TensorFlow model that includes a sequence of floating-point type conversions where the sequence can be simplified. The model must have at least two successive floating-point conversions that can either be collapsed into a single conversion or eliminated altogether if the final data type matches the initial data type of the sequence.

**Code Pattern Example:**
```python
import tensorflow as tf

# Define a tensor with a specific floating-point type
input_tensor = tf.constant([1.0, 2.0], dtype=tf.float32)

# First conversion: float32 to float64
converted_tensor = tf.cast(input_tensor, tf.float64)

# Second conversion: float64 back to float32
reconverted_tensor = tf.cast(converted_tensor, tf.float32)

# The sequence of conversions can be optimized by XLA to either remove conversions or replace them with a single step
```

In this example, since the final data type (`float32`) matches the initial data type of `input_tensor`, the conversions are redundant and can be optimized away, resulting in direct use of `input_tensor` without any data type change. This optimization reduces unnecessary computational overhead and memory usage associated with type conversions.