### Please generate one valid TensorFlow model that satisfies requirements below.
You should only use public TensorFlow APIs. The model can be used as the input to trigger the optimization pass `ReshapeReshapeForwarding` in TensorFlow XLA.

# Description
The model should contain the following pattern:
```
t1 = tf.reshape(input_tensor, ...)
t2 = tf.reshape(t1, input_tensor.shape)
```
The pattern describes that there are two reshape operators in the model. The first `reshape` operator transforms a tensor input `input_tensor` from `input_tensor.shape` to any new shape, and the second `reshape` operator transforms the output of first `reshape` back to `input_tensor.shape`.


# Model
class Model(tf.keras.Model):

  def __init__(self):
    super(Model, self).__init__()

  def call(self, x1):
    x2 = tf.reshape(x1, [2,2])
    return tf.reshape(x2, [4])

# Initializing the model
m = Model()

# Inputs to the model
input_shape = [4]
x1 = tf.constant([4.,5.,6.,7.], shape=input_shape)

# Call model
y = m(x1)




### Characteristics of TensorFlow Models for `ReshapeReshapeForwarding` Optimization

The `ReshapeReshapeForwarding` optimization in TensorFlow XLA is triggered when the model contains a sequence of two consecutive `tf.reshape` operations where the second reshape reverts the tensor to its original shape before the first reshape. This pattern effectively makes the two reshapes redundant as they cancel each other out.

#### Model Pattern:
```python
import tensorflow as tf

# Assuming input_tensor is a TensorFlow tensor with a known shape
t1 = tf.reshape(input_tensor, new_shape)  # First reshape to any new shape
t2 = tf.reshape(t1, tf.shape(input_tensor))  # Second reshape back to the original shape of input_tensor
```

#### Characteristics:
1. **Two Consecutive Reshapes**: The tensor undergoes two reshape operations in succession.
2. **Shape Reversion**: The output shape of the second reshape operation matches the shape of the tensor before the first reshape.
3. **No Intermediate Operations**: There are no operations between these two reshapes that alter the tensor, ensuring the shapes can be reverted cleanly.

### Characteristics of TensorFlow Models for `DotDecomposer` Optimization

The `DotDecomposer` optimization targets `Dot` operations (matrix multiplications) in TensorFlow XLA that are in a non-canonical form. The optimization aims to transform these operations into a canonical form to potentially simplify the operation or prepare it for further optimizations.

#### Model Pattern:
```python
import tensorflow as tf

# Example tensors with potentially non-canonical batch or contracting dimensions
tensor_a = tf.random.normal([10, 5, 20])
tensor_b = tf.random.normal([10, 20, 30])

# A dot product where dimensions might not be canonical
result = tf.tensordot(tensor_a, tensor_b, axes=[[2], [1]])
```

#### Characteristics:
1. **Non-canonical Contracting Dimensions**: The dot operation does not follow the canonical form where there is exactly one contracting dimension.
2. **Non-canonical Batch Dimensions**: The batch dimensions, if present, do not start from the 0th dimension or are not contiguous.
3. **Multiple Non-contracting Dimensions**: There are more than one non-contracting dimensions, or their arrangement is not canonical (either all at the start or all at the end of the dimension list).

These characteristics make the `Dot` operation a candidate for decomposition and reorganization into a form that might be more optimal for computation or further transformations by the compiler.