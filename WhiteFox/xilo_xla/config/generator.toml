# StarCoder Generation Configuration
# Configuration for generating test programs using VLLM

[paths]
prompt_dir = "prompts"
output_dir = "generated-outputs"
hf_home = "hf_cache"
log_file = "whitefox-llm-gen.log"
# WhiteFox-specific paths
bandit_state_file = "whitefox_state.json"



[model]
name = "bigcode/starcoder"
dtype = "float16"
max_model_len = 8192
gpu_memory_utilization = 0.95
swap_space = 20

[generation]
num_samples = 1     # Total number of output samples to generate per prompt
max_tokens = 4096    # Maximum number of tokens to generate for each output
temperature = 1.0    # Controls randomness (higher = more random)
top_p = 1.0          # Nucleus sampling limit (1.0 = consider all tokens)
split_size = 20      # Number of prompts processed together per batch
unit_num = 2        # Number of samples generated per batch call (until num_samples reached)
# WhiteFox-specific generation parameters
optimizations_dir = "xilo_xla/artifacts/Prompts/test"  # Path to requirement prompt directory
tests_per_optimization = 10  # Total tests to generate per optimization
tests_per_iteration = 5      # Tests to generate per iteration (10 tests per batch as per spec)
max_iterations = 15           # Maximum iterations per optimization
examples_per_prompt = 3        # Number of examples to include in feedback prompt (few-shot)

# Hardcoded list of optimizations that WhiteFox targets
optimizations = [
    "AllGatherBroadcastReorder",
    "AllGatherCombiner",
    "AllGatherDecomposer",
    "AllReduceCombiner",
    "AllReduceFolder",
    "AllReduceReassociate",
    "AllReduceSimplifier",
    "AsyncCollectiveCreator",
    "BatchDotSimplification",
    "Bfloat16ConversionFolding",
    "BroadcastCanonicalizer",
    "ChangeOpDataType",
    "CollectivesScheduleLinearizer",
    "ConcatForwarding",
    "ConditionalCanonicalizer",
    "ConvertAsyncCollectivesToSync",
    "ConvertMover",
    "Defuser",
    "DotDecomposer",
    "DotMerger",
    "DynamicIndexSplitter",
    "HloConstantFolding",
    "HloCse",
    "HloDce",
    "HloElementTypeConverter",
    "IdentityConvertRemoving",
    "IdentityReshapeRemoving",
    "LoopScheduleLinearizer",
    "MapInliner",
    "ReduceScatterCombiner",
    "ReduceScatterDecomposer",
    "ReduceScatterReassociate",
    "ReshapeBroadcastForwarding",
    "ReshapeReshapeForwarding",
    "ShardingRemover",
    "SimplifyFpConversions",
    "SliceConcatForwarding",
    "SliceSinker",
    "SortSimplifier",
    "StochasticConvertDecomposer",
    "TopkRewriter",
    "TransposeFolding",
    "TreeReductionRewriter",
    "TupleSimplifier",
    "WhileLoopConstantSinking",
    "WhileLoopExpensiveInvariantCodeMotion",
    "WhileLoopInvariantCodeMotion",
    "WhileLoopTripCountAnnotator",
    "ZeroSizedHloElimination",
]


[stopping]
eof_strings = [
    "<|endoftext|>",
    "###",
    "__output__ =",
    "if __name__",
    '"""',
    "'''",
    "# Model ends",
    "# LLVM IR ends",
    "# C++ Code ends",
]

[oracles]
float_rtol = 1e-5  # Relative tolerance for float comparison
float_atol = 1e-8  # Absolute tolerance for float comparison

[pass_name_aliases]
# Exact mappings from CamelCase optimization names to pass->name() strings from instrumentation
# No generic CamelCase -> kebab-case transform - use these exact mappings only
AllGatherBroadcastReorder = ["all-gather-bcast-reorder"]
AllGatherCombiner = ["all-gather-combiner", "gpu-all-gather-combiner"]
AllGatherDecomposer = ["all_gather_decomposer"]
AllReduceCombiner = ["all-reduce-combiner", "gpu-all-reduce-combiner"]
AllReduceFolder = ["all-reduce-folder"]
AllReduceReassociate = ["all-reduce-reassociate"]
AllReduceSimplifier = ["all-reduce-simplifier"]
AsyncCollectiveCreator = ["async-collective-creator"]
BatchDotSimplification = ["batch-dot-simplification"]
Bfloat16ConversionFolding = ["bfloat16-fold"]  # if this never matches, re-check the literal name() in your tree
BroadcastCanonicalizer = ["broadcast_canonicalizer"]
ChangeOpDataType = ["change-op-data-type"]
CollectivesScheduleLinearizer = ["collectives-schedule-linearizer"]
ConditionalCanonicalizer = ["conditional-canonicalizer"]
ConvertAsyncCollectivesToSync = ["convert-async-collectives-to-sync"]
ConvertMover = ["convert-mover"]
Defuser = ["defuser"]
DotDecomposer = ["dot_decomposer"]
DotMerger = ["dot-merger"]
DynamicIndexSplitter = ["dynamic-index-splitter"]
HloConstantFolding = ["constant_folding"]
HloCse = ["cse"]
HloDce = ["dce"]
HloElementTypeConverter = ["element_type_converter"]
LoopScheduleLinearizer = ["loop-schedule-linearizer"]
MapInliner = ["map-inline"]
ReduceScatterCombiner = ["reduce-scatter-combiner", "gpu-reduce-scatter-combiner"]
ReduceScatterDecomposer = ["reduce-scatter-decomposer"]
ReduceScatterReassociate = ["reduce-scatter-reassociate"]
ShardingRemover = ["sharding-remover"]
SimplifyFpConversions = ["simplify-fp-conversions"]
SliceSinker = ["slice-sinker"]
SortSimplifier = ["simplify-sorts"]
StochasticConvertDecomposer = ["stochastic_convert_decomposer"]
TopkRewriter = ["topk-rewriter"]
TransposeFolding = ["transpose-folding"]
TreeReductionRewriter = ["tree_reduction_rewriter", "tree-reduction-rewriter"]
TupleSimplifier = ["tuple-simplifier"]
WhileLoopConstantSinking = ["while-loop-constant-sinking"]
WhileLoopExpensiveInvariantCodeMotion = ["while-loop-expensive-invariant-code-motion"]
WhileLoopInvariantCodeMotion = ["while-loop-invariant-code-motion"]
WhileLoopTripCountAnnotator = ["while-loop-trip-count-annotator"]
ZeroSizedHloElimination = ["zero_sized_hlo_elimination"]

# These are NOT separate passes in your doc; they're behaviors inside DynamicDimensionSimplifier.
# So the only observable "pass=" you can match is dynamic-dimension-simplifier.
ConcatForwarding = ["dynamic-dimension-simplifier"]
IdentityConvertRemoving = ["dynamic-dimension-simplifier"]
IdentityReshapeRemoving = ["dynamic-dimension-simplifier"]
ReshapeBroadcastForwarding = ["dynamic-dimension-simplifier"]
ReshapeReshapeForwarding = ["dynamic-dimension-simplifier"]
SliceConcatForwarding = ["dynamic-dimension-simplifier"]

